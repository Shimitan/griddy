/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. griddy.jj */
/*@egen*/options {
    OUTPUT_DIRECTORY = "src/com/company";
                 
                                        
                                                       
                   
    LOOKAHEAD = 1;
}

PARSER_BEGIN(Griddy)
package com.company;
import com.company.parser.*;


import java.util.ArrayList;

public class Griddy/*@bgen(jjtree)*/implements GriddyTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTGriddyState jjtree = new JJTGriddyState();

/*@egen*/
    public static void main(String args[]) {
        Griddy parser = new Griddy(System.in);

        try {
            ASTStart n = parser.Start();
            if (args.length >0 && args[0].equals("t")) n.dump("");
            else {
                Visitor v = new Visitor();
                n.jjtAccept(v, "");
            }
        } catch (Exception e) {
            System.out.println("An error occurred.");
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }
}

PARSER_END(Griddy)

/* Whitespace characters */
SKIP : {
        < WHITE_SPACE:  <TAB> | <NEWLINE> | <SP>    >
    |   < #SP:   " "     >
    |   < #TAB:  "\t"    >
}

/* Comments */
SPECIAL_TOKEN : {
        <SINGLE_LINE_COMMENT:   "#" (~["\n","\r"])* <NEWLINE>   >
    |   < NEWLINE:  "\n" | "\r" | "\r\n"    >   // line endings
}

/* Reserved keywords */
TOKEN : {
        < IF:   "if"    >   // if statement
    |   < ELSE: "else"  >   // else statement
    |   < FROM: "from"  >   // get value 'from' board, e.g. '(x,y) from my_board'
    |   < ON:   "on"    >   // value exist on board, e.g. 'game_piece on my_board'
    |   < IN:   "in"    >   // e.g. 'for x in iterable'
    |   < FOR:  "for"   >   // for loop begin
    |   < WHILE:"while" >   // while loop begin
    |   < GAME_SETUP:   "SETUP" >   // setup phase begin
    |   < GAME_MAIN:    "GAME"  >   // game phase begin
    |   < FUNC_DECL:    "fun"   >   // function declaration
    |   < BOARD_DECL:   "board" >   // board declaration token, e.g. 'board (n,m)'
    |   < ECHO:         "echo"  >   // prints the output
}

/* Punctuators */
<DEFAULT, IN_REGEX>
TOKEN : {
        < EQ:   "=="    > : DEFAULT // equal
    |   < NEQ:  "!="    > : DEFAULT // 'not equal'
    |   < GEQ:  ">="    > : DEFAULT // 'greater than or equal to'
    |   < LEQ:  "<="    > : DEFAULT // 'less than or equal to'
    |   < NOT:  "!"     > : DEFAULT // 'not' / 'negate'
    |   < LT:   "<"     > : DEFAULT // 'less than'
    |   < GT:   ">"     > : DEFAULT // 'greater than'
    |   < AND:  "&&"    > : DEFAULT // logical 'and'
    |   < OR:   "||"    > : DEFAULT // logical 'or'
    |   < PLUS: "+"     > : DEFAULT // addition
    |   < MINUS:"-"     > : DEFAULT // subtraction
    |   < MULT: "*"     > : DEFAULT // multiplication
    |   < DIV:  "/"     > : DEFAULT // division
    |   < MOD:  "%"     > : DEFAULT // modulus
    |   < INCR:  "++"   > : DEFAULT // increment
    |   < DECR:  "--"   > : DEFAULT // decrement
    |   < ASSIGN: "="   > : DEFAULT // variable assigment
    |   < PLUS_ASSIGN:  "+="    > : DEFAULT // add and assign
    |   < MINUS_ASSIGN: "-="    > : DEFAULT // subtract and assign
    |   < MULT_ASSIGN:  "*="    > : DEFAULT // multiply and assign
    |   < DIV_ASSIGN:   "/="    > : DEFAULT // divide and assign
    |   < DOT:      "." > : DEFAULT     // dot (struct property access maybe?)
    |   < COMMA:    "," > : DEFAULT     // seperator comma
    |   < SEMICOLON: ";"> : DEFAULT     // statement endings
    |   < LPAREN:   "(" > : DEFAULT     // left parenthesis
    |   < RPAREN:   ")" > : IN_REGEX    // right parenthesis
    |   < LBRACE:   "{" > : DEFAULT     // left curly bracket
    |   < RBRACE:   "}" > : IN_REGEX    // right curly bracket
    |   < LBRACKET: "[" > : DEFAULT     // left square bracket
    |   < RBRACKET: "]" > : IN_REGEX    // right square bracket
}

/* Literals */
<DEFAULT, IN_REGEX>
TOKEN : {
        < BOOL: "true" | "false"    > : IN_REGEX
    |   < NULL: "empty" > : DEFAULT
    |   < NUM:  ["0"-"9"] | ["1"-"9"] (["0"-"9"])+  > : DEFAULT
    |   < NEG_NUM:  "-" <NUM>   > : DEFAULT
    |   < STRING:  "\"" (~["\"","\r","\n"])* "\"" > : DEFAULT // string literal
}

/* Identifier */
TOKEN : {
        < IDENT:        <IDENT_PART> (<IDENT_PART>)* >
    |   < #IDENT_PART:  (<LETTER> | "_")+ >
    |   < #LETTER:      ["a"-"z","A"-"Z"] >
}

ASTStart Start() : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
    try {
/*@egen*/
    setupPhase()
    gamePhase()
    <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void setupPhase()        : {/*@bgen(jjtree) Setup */
  ASTSetup jjtn000 = new ASTSetup(JJTSETUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Setup */
    try {
/*@egen*/
    <GAME_SETUP>
    (setupStmt())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void setupStmt()       : {}
{
        assignment() <SEMICOLON>
}

void gamePhase()       : {/*@bgen(jjtree) Game */
  ASTGame jjtn000 = new ASTGame(JJTGAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Game */
    try {
/*@egen*/
    <GAME_MAIN>
    (gameStmt())+/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void gameStmt()       : {}
{
        assignment() <SEMICOLON>
    |   echoStmt() <SEMICOLON>

}

void boardDeclaration()        :
{/*@bgen(jjtree) Board */
    ASTBoard jjtn000 = new ASTBoard(JJTBOARD);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token a, b;
    ArrayList<Integer> boardSize = new ArrayList<Integer>();
}
{/*@bgen(jjtree) Board */
    try {
/*@egen*/
    <BOARD_DECL> <LPAREN> a=<NUM> <COMMA> b=<NUM> <RPAREN>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        boardSize.add(Integer.parseInt(a.image));
        boardSize.add(Integer.parseInt(b.image));
        jjtn000.jjtSetValue(boardSize);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void assignment()         : {/*@bgen(jjtree) Assign */
  ASTAssign jjtn000 = new ASTAssign(JJTASSIGN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Assign */
    try {
/*@egen*/
    identifier() <ASSIGN> (boardDeclaration() | arrithmetic() | stringLiteral())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void primary()       : {}
{
        identifier()
    |   number()
}

void arrithmetic()       : {}
{
        <LPAREN> arrithmetic() <RPAREN>
    |   unary()
        (/*@bgen(jjtree) Mul */
            {
              ASTMul jjtn001 = new ASTMul(JJTMUL);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
            }
            try {
/*@egen*/   ( <MULT> arrithmetic()  )/*@bgen(jjtree)*/
            } catch (Throwable jjte001) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte001 instanceof RuntimeException) {
                throw (RuntimeException)jjte001;
              }
              if (jjte001 instanceof ParseException) {
                throw (ParseException)jjte001;
              }
              throw (Error)jjte001;
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001, true);
              }
            }
/*@egen*/     
        |/*@bgen(jjtree) Div */
            {
              ASTDiv jjtn002 = new ASTDiv(JJTDIV);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
            }
            try {
/*@egen*/   ( <DIV> arrithmetic()   )/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002, true);
              }
            }
/*@egen*/     
        |/*@bgen(jjtree) Mod */
            {
              ASTMod jjtn003 = new ASTMod(JJTMOD);
              boolean jjtc003 = true;
              jjtree.openNodeScope(jjtn003);
            }
            try {
/*@egen*/   ( <MOD> arrithmetic()   )/*@bgen(jjtree)*/
            } catch (Throwable jjte003) {
              if (jjtc003) {
                jjtree.clearNodeScope(jjtn003);
                jjtc003 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte003 instanceof RuntimeException) {
                throw (RuntimeException)jjte003;
              }
              if (jjte003 instanceof ParseException) {
                throw (ParseException)jjte003;
              }
              throw (Error)jjte003;
            } finally {
              if (jjtc003) {
                jjtree.closeNodeScope(jjtn003, true);
              }
            }
/*@egen*/     
        |/*@bgen(jjtree) Add */
            {
              ASTAdd jjtn004 = new ASTAdd(JJTADD);
              boolean jjtc004 = true;
              jjtree.openNodeScope(jjtn004);
            }
            try {
/*@egen*/   ( <PLUS> arrithmetic()  )/*@bgen(jjtree)*/
            } catch (Throwable jjte004) {
              if (jjtc004) {
                jjtree.clearNodeScope(jjtn004);
                jjtc004 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte004 instanceof RuntimeException) {
                throw (RuntimeException)jjte004;
              }
              if (jjte004 instanceof ParseException) {
                throw (ParseException)jjte004;
              }
              throw (Error)jjte004;
            } finally {
              if (jjtc004) {
                jjtree.closeNodeScope(jjtn004, true);
              }
            }
/*@egen*/     
        |/*@bgen(jjtree) Sub */
            {
              ASTSub jjtn005 = new ASTSub(JJTSUB);
              boolean jjtc005 = true;
              jjtree.openNodeScope(jjtn005);
            }
            try {
/*@egen*/   ( <MINUS> arrithmetic() )/*@bgen(jjtree)*/
            } catch (Throwable jjte005) {
              if (jjtc005) {
                jjtree.clearNodeScope(jjtn005);
                jjtc005 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte005 instanceof RuntimeException) {
                throw (RuntimeException)jjte005;
              }
              if (jjte005 instanceof ParseException) {
                throw (ParseException)jjte005;
              }
              throw (Error)jjte005;
            } finally {
              if (jjtc005) {
                jjtree.closeNodeScope(jjtn005, true);
              }
            }
/*@egen*/     
        )*
}

void unary()       :
{
    Token t = null;
}
{
      t=<PLUS> arrithmetic()
    | t=<MINUS> arrithmetic()
    |   number()
    |   identifier()
}

ASTIdent identifier()        : {/*@bgen(jjtree) Ident */
    ASTIdent jjtn000 = new ASTIdent(JJTIDENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Ident */
    try {
/*@egen*/
    t=<IDENT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setName(t.image);
        return jjtn000;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

ASTInteger number()          :
{/*@bgen(jjtree) Integer */
    ASTInteger jjtn000 = new ASTInteger(JJTINTEGER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Integer */
    try {
/*@egen*/
    t=<NUM>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.jjtSetValue(Integer.parseInt(t.image));
        return jjtn000;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

ASTString stringLiteral()         :
{/*@bgen(jjtree) String */
    ASTString jjtn000 = new ASTString(JJTSTRING);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) String */
    try {
/*@egen*/
    t=<STRING>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.jjtSetValue(t.image.substring(1, (t.image.length() - 1)));
        return jjtn000;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

ASTEcho echoStmt()       :
{/*@bgen(jjtree) Echo */
    ASTEcho jjtn000 = new ASTEcho(JJTECHO);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Echo */
    try {
/*@egen*/
    <ECHO> ( arrithmetic() | stringLiteral() )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}