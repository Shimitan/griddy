package com.company.codegen;

import com.company.Util;

public class TargetC implements OutputTemplates {

    public String typeString(String str) {
        return "\"" + str + "\"";
    }

    public String typeNumber(int num) {
        return "" + num;
    }

    public String typeBoolean(boolean bool) {
        return bool ? "1" : "0";
    }

    public String pieceDef(String ident, GriddyStructure.SetupStruct.PieceDef pieceDef) {
        var displayName = pieceDef.pieceProps.name;
        return ident + ".name = calloc(" + (displayName.length() + 1) + ", sizeof(char));\n"
                + "strcpy(" + ident + ".name, \"" + displayName + "\");\n"
                + ident + ".limit = " + pieceDef.pieceProps.limit + ";\n"
                + ident + ".count = " + pieceDef.pieceProps.count + ";\n"
                + ident + ".capture = " + (pieceDef.pieceProps.capture ? "1" : "0") + ";\n"
                + ident + ".can_jump = " + (pieceDef.pieceProps.canJump ? "1" : "0") + ";\n"
                + ident + ".placeable = " + (pieceDef.pieceProps.placeable ? "1" : "0") + ";\n"
                + ident + ".player = &" + pieceDef.ownerPrefix + ";\n";
    }

    public String playerDef(GriddyStructure.SetupStruct.PlayerDef playerDef) {
        var out = new StringBuilder("struct Player {\n");
        playerDef.player1.forEach( (k, _v) -> out.append("struct Piece " + k + ";\n") );
        out.append("} _p1, _p2;\n");
        playerDef.player1.forEach( (_k, v) -> out.append(v) );
        playerDef.player2.forEach( (_k, v) -> out.append(v) );
        return out.toString();
    };

    public String setup(GriddyStructure.SetupStruct setupStruct) {
        var out = """
                /*    SETUP    */
                """
                + setupStruct.playerDef.toString()
                + "struct Piece *_board[" + setupStruct.boardHeight + "][" + setupStruct.boardWidth + "] = {";

        for (GriddyStructure.SetupStruct.PieceDef[] row : setupStruct.getBoard()) {
            out += "{";
            for (GriddyStructure.SetupStruct.PieceDef pieceDef : row)
                if (pieceDef != null) {
                    out += "&" + pieceDef.ownerPrefix + "." + pieceDef.pieceProps.name + ",";
                } else out += "NULL,";

            out += "},";
        }

        return out + """
                };
                struct Player * _current_player;
                int _turn_count = 0;
                int _win_condition = 0;
                """
                + setupStruct.body.toString();
    }

    public String game(String body, String winCond) {
        return """
                /*   GAME    */
                do {
                _current_player = _turn_count % 2 ? &_p2 : &_p1;
                """
                + body
                + """
                _win_condition"""
                + " = "
                + winCond
                + ";\n"
                + """
                _turn_count++;
                } while (!_win_condition);
                
                """;
    }

    public String wrapper(GriddyStructure.SetupStruct setupStruct, GriddyStructure.GameStruct gameStruct) {
        return """
                /* === Code generated by Griddy compiler === */
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <stdbool.h>

                int main(int argc, char *argv[]){
                struct Piece {
                char* name;
                unsigned int limit;
                unsigned int count;
                bool placeable;
                bool capture;
                bool can_jump;
                struct Player* player;
                };
                """
                + setupStruct
                + "\n"
                + gameStruct
                + """
                return 0;
                }
                """;
    }

    public String outputString(String body) {
        return "printf(\"%s\\n\", " + body + ");\n";
    }

    public String outputNumber(String body) {
        return "printf(\"%d\\n\", " + body + ");\n";
    }

    public String outputTable(int w, int h) {
        var letterRow = new StringBuilder();
        for (int n : Util.range(1, w))
            letterRow.append("  ").append((char)('a' + n - 1)).append(" ");

        return "printf(\"┌───" + "┬───".repeat(Math.max(0, w - 1)) + "┐\\n\");\n"
                + "for (int _i = " + (h - 1) + "; _i >= 0; _i--) {\n"
                + "for (int _j = 0; _j < " + w + "; _j++)\n"
                + """
                if (_board[_i][_j]) {
                if (_board[_i][_j]->player == &_p1) {
                printf("│ \\x1b[33m\\x1b[1m%c\\x1b[0m ", *_board[_i][_j]->name);
                } else printf("│ %c ", *_board[_i][_j]->name);
                } else printf("│   ");
                printf("│ %d\\n", _i + 1);
                """
                + "if (_i > 0) printf(\"├───" + "┼───".repeat(Math.max(0, w - 1)) + "┤\\n\");\n}\n"
                + "printf(\"└───" + "┴───".repeat(Math.max(0, w - 1)) + "┘\\n\");\n"
                + "printf(\"" + letterRow + "\\n\");\n";
    }

    public String condStmt(String condition, String body) {
        return "if (" + condition + ") {\n" + body + "}\n";
    }

    public String condElse(String body) {
        return "\n} else {\n" + body;
    }

    public String assignPieceRef(String ident, int x, int y) {
        return "struct Piece * " + ident + " = " + pieceRef(x, y) + ";\n";
    }

    public String pieceRef(int x, int y) {
        return "_board[" + (y - 1) + "][" + (x - 1) + "]";
    }

    public String reAssignVar(String ident, String body) {
        return ident + " = " + body + ";\n";
    }

    public String assignString(String ident, String body) {
        return "char *" + ident + ";\n"
                + ident + " = calloc(" + (body.length() + 1) + ", sizeof(char));\n"
                + "strcpy(" + ident + ", \"" + body + "\");\n";
    }

    public String reAssignString(String ident, String body) {
        return ident + " = realloc(" + ident + ", " + (body.length() + 1) + ");\n"
                + "strcpy(" + ident + ", " + body + ");\n";
    }

    public String assignNumber(String ident, String body) {
        return "int " + reAssignNumber(ident, body);
    }

    public String reAssignNumber(String ident, String body) {
        return reAssignVar(ident, body);
    }

    public String assignBoolean(String ident, String body) {
        return assignNumber(ident, body);
    }

    public String reAssignBoolean(String ident, String body) {
        return reAssignNumber(ident, body);
    }

    public String logicalOperator(String token) {
        return switch (token) {
            case "and" -> "&&";
            case "or" -> "||";
            case ">=" -> ">=";
            case "<=" -> "<=";
            case "==" -> "==";
            case "!=" -> "!=";
            case "<" -> "<";
            case ">" -> ">";
            default -> throw new RuntimeException("Unknown logical operator: " + token);
        };
    }

    public String place(String pieceIdent) {
        return """
                char _place_arg_x;
                int _place_arg_y;
                PLACE_INPUT:
                printf("Input: ");
                scanf("%c%d", &_place_arg_x, &_place_arg_y);
                int _in;
                while ((_in = getchar()) != EOF && _in != '\\n');
                """
                + "if (_current_player->" + pieceIdent + ".placeable&&_current_player->" + pieceIdent
                + ".count<_current_player->" + pieceIdent + ".limit&&_board[_place_arg_y-1][_place_arg_x-((int)'a')]==NULL){\n"
                + "_board[_place_arg_y-1][_place_arg_x-((int)'a')]=&_current_player->" + pieceIdent + ";\n"
                + "_current_player->" + pieceIdent + ".count++;\n"
                + """
                } else {
                printf("Invalid piece placement! Try again:\\n");
                goto PLACE_INPUT;
                }
                """;
    }

    public String tile(int x, int y) {
        return "_board[" + (y - 1) + "][" + (x - 1) + "]";
    }

    public String unaryNot(String body) {
        return "!(" + body + ")";
    }
}
